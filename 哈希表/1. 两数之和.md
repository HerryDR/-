这是一个经典的 **两数之和** 问题。给定一个整数数组 `nums` 和一个目标值 `target`，我们需要找出两个数字，它们的和为 `target`，并返回它们的数组下标。

### 解决思路：

1. **暴力解法**：我们可以通过两个嵌套的 `for` 循环，遍历所有的可能组合，找出和为 `target` 的两个元素。时间复杂度是 `O(n^2)`，其中 `n` 是数组的长度。

2. **优化解法**：利用哈希表（HashMap）来优化搜索过程。通过哈希表存储已经遍历过的数字及其下标，当前元素与目标值的差值 `target - num[i]` 是否存在于哈希表中。如果存在，说明找到了结果。

   - 时间复杂度：`O(n)`，只需要遍历一次数组。
   - 空间复杂度：`O(n)`，需要额外的空间来存储哈希表。

### 代码实现：

```java
import java.util.HashMap;
import java.util.Map;

class Solution {
    public int[] twoSum(int[] nums, int target) {
        // 创建一个哈希表，用来存储数字和其对应的下标
        Map<Integer, Integer> map = new HashMap<>();
        
        // 遍历数组
        for (int i = 0; i < nums.length; i++) {
            int temp = target - nums[i]; // 计算补数

            // 如果补数已经存在于哈希表中，说明找到了答案
            if (map.containsKey(temp)) {
                return new int[] { map.get(temp), i }; // 返回补数的下标和当前数字的下标
            }
            
            // 如果补数不存在，将当前数字和其下标存入哈希表
            map.put(nums[i], i);
        }
        
        // 如果没有找到符合条件的答案
        r
    }
}
```

### 代码解释：

1. **哈希表 `map`**：用于存储每个数字和它对应的索引。
2. **`complement = target - nums[i]`**：计算当前数字 `nums[i]` 的补数，即 `target - nums[i]`。
3. **判断补数是否在哈希表中**：
   - 如果补数已经存在，说明找到了目标值为 `target` 的两个数字，返回它们的下标。
   - 如果补数不存在，将当前数字和其下标存入哈希表中。
4. **如果没有找到符合条件的两个数字**，抛出异常，表示没有解。

### 示例：

假设我们有以下输入：
```java
int[] nums = {2, 7, 11, 15};
int target = 9;
```

- 初始时，哈希表为空。
- 当 `i = 0` 时，`nums[0] = 2`，我们计算 `complement = 9 - 2 = 7`。哈希表中没有 `7`，所以将 `2` 和它的下标 `0` 存入哈希表 `{2: 0}`。
- 当 `i = 1` 时，`nums[1] = 7`，我们计算 `complement = 9 - 7 = 2`。哈希表中存在 `2`，所以返回 `[0, 1]`，即 `nums[0]` 和 `nums[1]` 的和为 `9`。

### 时间复杂度：
- 时间复杂度：`O(n)`，其中 `n` 是数组的长度。我们只遍历一次数组，且每次查找和插入哈希表的时间复杂度都是 `O(1)`。
  
### 空间复杂度：
- 空间复杂度：`O(n)`，我们使用了一个哈希表来存储数组中的每个元素。

### 总结：
这道题的最优解法使用哈希表，能够在一次遍历中找到答案，时间复杂度为 `O(n)`，比暴力解法的 `O(n^2)` 更高效。