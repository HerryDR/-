### **151.反转字符串中的单词**

#### **题目要求**

- 给定一个字符串 `s`，反转字符串中的单词顺序。
- 单词是由非空格字符组成的子字符串，单词之间用单个空格分隔。
- 输入字符串可能包含前导、尾随或多余的中间空格。
- 返回的结果必须是单词间用单个空格分隔且没有额外空格的字符串。

------

#### **思路分析**

1. **去掉首尾空格**：使用 `trim()` 方法去除字符串两端的空格。
2. 逐字符遍历：
   - 如果遇到非空格字符，将其加入当前单词 `sub` 中。
   - 如果遇到空格，且当前单词 sub非空：
     - 将 `sub` 反向插入到结果字符串 `ans` 的最前面。
     - 同时插入一个空格作为分隔符。
     - 清空当前单词 `sub`。
3. **处理最后一个单词**：遍历结束后，将最后累积的单词插入到 `ans` 的最前面。
4. **返回结果**：最终构造的字符串即为所需结果。

------

#### **代码实现**

```java
class Solution {
    public String reverseWords(String s) {
        s = s.trim(); // 去掉首尾多余空格
        int n = s.length();
        StringBuilder sub = new StringBuilder(); // 当前单词
        StringBuilder ans = new StringBuilder(); // 最终结果
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) != ' ') { // 累积字符到当前单词
                sub.append(s.charAt(i));
            } else if (sub.length() > 0) { // 遇到空格并且当前单词存在
                ans.insert(0, sub.toString()); // 反向插入单词
                ans.insert(0, ' '); // 插入空格
                sub.setLength(0); // 清空当前单词
            }
        }
        ans.insert(0, sub.toString()); // 插入最后一个单词
        return ans.toString();
    }
}
```

------

#### **复杂度分析**

1. **时间复杂度**：

   - 遍历字符串 `s` 一次，时间复杂度为 O(n)O(n)，其中 nn 是字符串的长度。
   - `StringBuilder.insert(0, str)` 每次操作的复杂度为 O(k)O(k)，`k` 是 `ans` 当前的长度，最坏情况下整体复杂度约为 O(n2)O(n^2)。

   **优化建议**：可以使用 `split` 方法或直接使用栈存储单词，避免频繁插入。

2. **空间复杂度**：

   - 使用了 `StringBuilder` 存储结果，额外的空间复杂度为 O(n)O(n)。

------

#### **关键点总结**

1. **去除多余空格**：使用 `trim()` 去掉首尾空格，避免边界问题。
2. **单词反向插入**：通过 `StringBuilder.insert(0, ...)` 实现结果字符串的倒序构造。
3. **处理多余空格**：通过判断当前单词是否存在 `sub.length() > 0`，避免插入多余的空格。
4. **最后一个单词的插入**：遍历结束后，不要忘记插入累积的最后一个单词。

------

#### **扩展优化**

- **优化插入操作**：避免 `insert(0, ...)` 的高复杂度，可以用栈或反向遍历后再 `join`。
- **其他语言实现**：可以参考 Python 的 `split()` 和 `join()` 方法高效实现类似功能。