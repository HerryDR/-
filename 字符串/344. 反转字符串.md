### 344.反转字符串

------

#### **题目分析**

- **输入**：一个以字符数组形式给出的字符串 `s`。
- **输出**：将字符数组 `s` 原地反转（即修改输入数组，无需分配额外空间）。
- 约束：
  1. 必须在原数组上操作。
  2. 空间复杂度为 O(1)。

------

#### **解题思路**

1. **双指针法**：
   - 使用两个指针，一个从左向右（`left`），一个从右向左（`right`）。
   - 交换两个指针指向的字符，然后分别移动指针。
   - 当两个指针相遇或交错时，反转完成。
2. **原地修改**：
   - 通过一个临时变量 `temp` 交换字符，保证操作在原数组中完成，不需要分配额外空间。

------

#### **代码**

```java
class Solution {
    public void reverseString(char[] s) {
        int left = 0;
        int right = s.length - 1;
        while (left < right) {
            char temp = s[left];   // 暂存左边字符
            s[left] = s[right];   // 将右边字符赋值到左边
            s[right] = temp;      // 将左边字符赋值到右边
            left++;               // 左指针右移
            right--;              // 右指针左移
        }
    }
}
```

------

#### **复杂度分析**

1. **时间复杂度**：
   - 每次交换需要 O(1)的时间，循环执行 n/2 次（n 为字符数组长度），因此时间复杂度为： O(n)
2. **空间复杂度**：
   - 只使用了常数级的额外变量（如 `temp`、指针变量），因此空间复杂度为： O(1)

------

#### **执行步骤**

以输入 `s = ['h', 'e', 'l', 'l', 'o']` 为例：

1. 初始化：

   ```text
   left = 0, right = 4
   s = ['h', 'e', 'l', 'l', 'o']
   ```

2. 第一次交换：

   ```text
   s[0] ↔ s[4] → s = ['o', 'e', 'l', 'l', 'h']
   left = 1, right = 3
   ```

3. 第二次交换：

   ```text
   s[1] ↔ s[3] → s = ['o', 'l', 'l', 'e', 'h']
   left = 2, right = 2
   ```

4. 停止条件：

   - 当 `left >= right` 时，循环结束。

最终结果：

```text
s = ['o', 'l', 'l', 'e', 'h']
```

------

#### **总结与注意事项**

1. **适用场景**：
   - 使用双指针法适用于对数组/字符串需要在原地操作的问题。
2. **边界条件**：
   - 空数组：无需反转，直接返回。
   - 单字符数组：无需操作，因为其反转结果为自身。
3. **优化点**：
   - 当前实现已经最优，符合题目对时间和空间的要求。

------

#### **扩展思考**

- 如果要求反转的是字符串而非字符数组，则需要将字符串先转换为字符数组，再反转后返回新字符串：

  ```java
  public String reverseString(String s) {
      char[] arr = s.toCharArray();
      int left = 0, right = arr.length - 1;
      while (left < right) {
          char temp = arr[left];
          arr[left] = arr[right];
          arr[right] = temp;
          left++;
          right--;
      }
      return new String(arr);
  }
  ```