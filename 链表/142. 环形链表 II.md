

检测链表环的经典方法是使用“快慢指针”算法。以下是实现思路：

1. **初始化两个指针**：设置快指针（`fast`）和慢指针（`slow`），都从头节点开始。
2. **快慢指针遍历**：快指针每次走两步，慢指针每次走一步。如果链表有环，快慢指针必定会相遇。
3. **判断是否相遇**：如果快指针和慢指针相遇，说明链表有环。
4. **找到环的入口**：将慢指针重置到头节点位置，快指针保持在相遇点，然后每次两个指针各走一步。两者再次相遇的节点就是环的起始节点。

代码实现如下：

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) {
            return null;
        }
        
        ListNode slow = head;
        ListNode fast = head;

        // 使用快慢指针判断是否有环
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            
            if (slow == fast) {
                // 将慢指针重置为头节点
                slow = head;
                
                // 两指针相遇点就是环的入口
                while (slow != fast) {
                    slow = slow.next;
                    fast = fast.next;
                }
                
                return slow; // 返回环的起始节点
            }
        }
        
        return null; // 没有环
    }
}
```

这段代码的时间复杂度为 \(O(n)\)，空间复杂度为 \(O(1)\)，适用于链表检测环并找到入口的情况。

### **寻找入口的数学推导**

找到环的入口的原理基于快慢指针的运动规律和一些数学推导。假设链表从头节点到环的入口有距离 \(a\)，从环的入口到快慢指针相遇点有距离 \(b\)，相遇点到环的入口再回到相遇点的距离为 \(c\)。具体推导如下：

1. **快慢指针的路径**：
   - 慢指针一次走一步，而快指针一次走两步，因此快指针的路程是慢指针的两倍。
   - 在相遇时，假设慢指针走过的总路程为 \(a + b\)（从头到相遇点），那么快指针走的总路程就是2(a+b)\。

2. **链表的环路关系**：
   
   - 由于快指针在环内追上了慢指针，快指针必定比慢指针多走了一圈的距离，即多走了环的长度 \(c\) 的整数倍。所以我们可以表示快慢指针的关系为：
     $$
     2(a+b)=a+b+k⋅c
     $$
     其中 \(k\) 是整数，表示快指针多走了 \(k\) 圈。
   
   - 化简后可得：
     $$
     a = k \cdot c - b
     $$
     这说明从相遇点到环入口的距离 \(c - b\) 与从链表头到环入口的距离 \(a\) 是相等的距离。
   
3. **重置慢指针**：
   
   - 由于从相遇点到环入口的距离等于从头节点到环入口的距离，因此我们可以将慢指针从相遇点重新移动到头节点，同时保持快指针在相遇点，并让两指针同时向前一步步移动。
   - 当两个指针相遇时，它们正好会在环的入口处重合。

这就是找到环入口的关键原理。