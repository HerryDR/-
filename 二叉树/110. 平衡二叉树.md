### **110. 平衡二叉树**

#### **题目描述：**

给定一棵二叉树，判断它是否是平衡二叉树。
 **平衡二叉树**的定义是：一个二叉树每个节点的左右子树的高度差的绝对值不超过 1。

#### **解题思路：**

1. **递归法**
    使用递归计算每个节点的左右子树的高度，并在递归过程中判断左右子树的高度差是否大于1。如果任何一个节点的左右子树高度差超过1，则该树不平衡。
   - **返回值**: 如果树是平衡的，则返回树的高度；如果树不平衡，则返回 `-1`。
   - 递归条件:
     - 如果节点为空，返回 0。
     - 如果左右子树高度差大于1，返回 `-1`，表示不平衡。
2. **算法步骤：**
   - 从根节点开始递归检查每个节点。
   - 递归计算左子树和右子树的高度。
   - 比较左子树和右子树的高度差，如果大于1，直接返回 `-1`，表示不平衡。
   - 如果递归过程中发现任何不平衡的节点，直接返回 `-1`。
   - 否则，返回树的高度。

#### **代码实现：**

```java
class Solution {
    // 判断二叉树是否平衡
    public boolean isBalanced(TreeNode root) {
        return getHeight(root) != -1;
    }

    // 计算树的高度，若树不平衡返回 -1
    public int getHeight(TreeNode root) {
        if (root == null) {
            return 0;  // 空节点的高度为 0
        }

        // 计算左子树的高度
        int leftHeight = getHeight(root.left);
        if (leftHeight == -1) {  // 如果左子树不平衡，直接返回
            return -1;
        }

        // 计算右子树的高度
        int rightHeight = getHeight(root.right);
        if (rightHeight == -1) {  // 如果右子树不平衡，直接返回
            return -1;
        }

        // 检查当前节点的左右子树高度差
        if (Math.abs(leftHeight - rightHeight) > 1) {
            return -1;  // 不平衡，返回 -1
        }

        // 返回当前节点的高度
        return 1 + Math.max(leftHeight, rightHeight);
    }
}
```

#### **代码注释解释：**

1. **`isBalanced` 方法**:
   - 该方法负责调用递归函数 `getHeight` 来检查整棵树是否平衡。
   - 如果 `getHeight` 返回值为 `-1`，表示树不平衡，返回 `false`；否则返回 `true`。
2. **`getHeight` 方法**:
   - 递归计算树的高度。
   - 如果子树不平衡（即返回值为 `-1`），则直接返回 `-1`，并停止递归。
   - 如果当前节点的左右子树高度差超过1，则返回 `-1`，表示当前树不平衡。
   - 计算当前节点的高度，返回 `1 + Math.max(leftHeight, rightHeight)`。

#### **时间复杂度与空间复杂度：**

- **时间复杂度**: `O(n)`，其中 `n` 是二叉树的节点数。每个节点被访问一次。
- **空间复杂度**: `O(h)`，其中 `h` 是树的高度。递归栈的深度取决于树的高度。最坏情况下，树是链状的，空间复杂度为 `O(n)`；最好的情况下，树是平衡的，空间复杂度为 `O(log n)`。

#### **总结：**

- 本题通过递归方法实现了平衡二叉树的判断。
- 利用递归获取树的高度，并在获取高度的过程中判断左右子树的平衡情况。
- 递归的终止条件是树为空或者树的左右子树高度差大于1。