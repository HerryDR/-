### **108. 将有序数组转换为二叉搜索树**

------

#### **题目描述**

给定一个按升序排列的整数数组 `nums`，将其转换为一棵 **平衡二叉搜索树**。
 **平衡二叉搜索树**定义：

- 每个节点的左右子树高度差不超过 1。
- 左子树所有节点的值小于根节点值，右子树所有节点的值大于根节点值。

------

#### **解题思路**

这道题的核心是通过 **分治法** 构造平衡二叉搜索树：

1. **选择中间节点作为根节点**：
   - 数组中间值是最接近中点的元素，作为当前子树的根节点。
   - 中间值索引：`mid = (left + right) / 2`。
2. **递归构造左右子树**：
   - 左子树由数组左半部分构成，范围是 `[left, mid - 1]`。
   - 右子树由数组右半部分构成，范围是 `[mid + 1, right]`。
3. **递归终止条件**：
   - 当 `left > right`，返回 `null`。
4. **平衡性保障**：
   - 每次选择中间节点作为根，能保证左右子树高度差尽可能小。

------

#### **代码实现**

##### **递归解法**

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return buildTree(nums, 0, nums.length - 1);
    }

    private TreeNode buildTree(int[] nums, int left, int right) {
        // 递归终止条件
        if (left > right) {
            return null;
        }

        // 选择中间元素作为当前根节点
        int mid = (left + right) / 2;
        TreeNode root = new TreeNode(nums[mid]);

        // 构造左子树和右子树
        root.left = buildTree(nums, left, mid - 1);
        root.right = buildTree(nums, mid + 1, right);

        return root;
    }
}
```

------

#### **复杂度分析**

- 时间复杂度：O(n)
  - 每个节点访问一次，共有 n 个节点。
- 空间复杂度：O(log n)
  - 递归调用栈的深度为树的高度，平衡树的高度为 O(log n)。

------

#### **举例分析**

##### **输入**：

```text
nums = [-10, -3, 0, 5, 9]
```

##### **过程**：

1. **根节点**：取中间值 `nums[2] = 0`。
2. 左子树：
   - 构建左子树的数组为 `[-10, -3]`。
   - 取中间值 `nums[0] = -10` 作为根，`-3` 为其右子树。
3. 右子树：
   - 构建右子树的数组为 `[5, 9]`。
   - 取中间值 `nums[3] = 5` 作为根，`9` 为其右子树。

##### **输出**：

```text
      0
     / \
   -10   5
     \     \
     -3     9
```

------

#### **总结**

- **核心思想**：分治法，递归构造左右子树，选择中间元素作为根节点以保证平衡性。
- 代码关键点：
  - 确定递归终止条件：`left > right`。
  - 计算中间位置：`mid = (left + right) / 2`。
  - 分别递归构建左右子树。
- 适用场景：
  - 需要构造平衡二叉搜索树的问题。
  - 递归分治法处理有序数据结构。

------

#### **代码优化**

对于递归方法来说，当前实现已经最优。