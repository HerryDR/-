### **112. 合并两棵二叉树**

------

#### **题目描述**

给定两棵二叉树 `root1` 和 `root2`，要求将两棵树合并为一棵新二叉树。合并规则如下：

1. 如果两个节点重叠，将两个节点值相加作为新节点的值。
2. 如果某个节点为空，则直接使用另一个非空节点。

返回合并后的二叉树。

------

#### **解题思路**

1. **递归方法**：
   - 如果两棵树的节点都存在，则相加后递归合并左右子树。
   - 如果某一棵树的节点为空，则直接返回另一棵树的节点。
   - 使用递归处理每个节点，逐层向下合并。
2. **终止条件**：
   - 当 `root1` 或 `root2` 为空时，返回另一棵树的节点。
3. **递归返回值**：
   - 每次递归返回合并后的节点，作为上一层节点的左子树或右子树。

------

#### **代码实现**

**递归解法：**

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null) return root2; // 如果第一棵树为空，直接返回第二棵树
        if (root2 == null) return root1; // 如果第二棵树为空，直接返回第一棵树
        
        // 合并当前节点
        TreeNode root = new TreeNode(root1.val + root2.val);
        
        // 递归合并左右子树
        root.left = mergeTrees(root1.left, root2.left);
        root.right = mergeTrees(root1.right, root2.right);
        
        return root;
    }
}
```

------

#### **复杂度分析**

1. **时间复杂度**：
   - 每个节点只会访问一次，假设两棵树共有 `n` 个节点，则时间复杂度为 **O(n)**。
2. **空间复杂度**：
   - 递归调用的栈深度取决于树的高度，最坏情况下空间复杂度为 **O(h)**，其中 `h` 是较高树的高度。

------

#### **测试用例**

**输入：**

```text
root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
```

**输出：**

```text
[3,4,5,5,4,null,7]
```

**示意图：**

- ```
  root1
  ```

  :

  ```
      1
     / \
    3   2
   / 
  5  
  ```

- ```
  root2
  ```

  :

  ```
      2
     / \
    1   3
     \    \
      4    7
  ```

- 合并后：

  ```
      3
     / \
    4   5
   / \    \
  5   4    7
  ```

------

#### **总结**

1. 递归的核心是确定合并规则：
   - 当前节点值相加。
   - 左子树与左子树合并，右子树与右子树合并。
2. 时间复杂度和空间复杂度与树的大小和高度相关，保证效率的同时简化了代码逻辑。
3. 面试时需要注意在合并空节点时返回非空节点的逻辑。