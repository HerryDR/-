### **222. 完全二叉树的节点个数**

#### **题目描述**

给你一棵 **完全二叉树** 的根节点 `root`，求出该树的节点个数。

**完全二叉树** 定义：

1. 除了最底层节点可能未填满外，其余每层节点数均达到最大值。
2. 最底层的节点集中在最左边的若干位置。

------

#### **解题思路**

这道题利用完全二叉树的特性，可以通过递归加速计算节点数，无需遍历整棵树。

##### **算法思路**

1. **完全二叉树的高度计算**：
   - 通过沿着左子节点一直向下，计算树的高度。
   - 高度的计算复杂度为 **O(log n)**。
2. **左右子树高度比较**：
   - 如果左右子树高度相等，则说明左子树是满二叉树：
     - 左子树节点数 = `2^leftHeight - 1`。
     - 再加上根节点和右子树的节点数递归计算。
   - 如果左右子树高度不相等，则说明右子树是满二叉树：
     - 右子树节点数 = `2^rightHeight - 1`。
     - 再加上根节点和左子树的节点数递归计算。
3. **位运算加速计算**：
   - 使用位运算 `1 << height` 快速计算 `2^height`，从而优化效率。

------

#### **代码实现**

```java
class Solution {
    public int countNodes(TreeNode root) {
        // 如果树为空，节点数为 0
        if (root == null) {
            return 0;
        }

        // 计算左子树和右子树的高度
        int leftHeight = getHeight(root.left);
        int rightHeight = getHeight(root.right);

        if (leftHeight == rightHeight) {
            // 左子树是满二叉树，节点数为 2^leftHeight - 1，加上根节点和右子树
            return (1 << leftHeight) - 1 + 1 + countNodes(root.right);
        } else {
            // 右子树是满二叉树，节点数为 2^rightHeight - 1，加上根节点和左子树
            return (1 << rightHeight) - 1 + 1 + countNodes(root.left);
        }
    }

    // 计算二叉树高度（沿左子节点向下）
    public int getHeight(TreeNode root) {
        int h = 0;
        while (root != null) {
            h++;
            root = root.left;
        }
        return h;
    }
}
```

------

#### **复杂度分析**

1. **时间复杂度**：
   - 每次递归调用会计算一次树的高度，时间复杂度为 **O(log n)**。
   - 树的高度为 **O(log n)**，因此递归深度也是 **O(log n)**。
   - 总时间复杂度为 **O((log n)^2)**。
2. **空间复杂度**：
   - 递归调用栈的深度为树的高度 **O(log n)**。
   - 空间复杂度为 **O(log n)**。

------

#### **题目总结**

1. 本题充分利用了 

   完全二叉树的特性：

   - 可以通过高度快速计算满二叉树的节点数。

2. 使用递归的方式拆解问题，同时通过 **位运算** 优化了计算速度。

3. 优化亮点：

   - 不需要遍历所有节点即可求出节点总数，大大提高了效率。