### **239.滑动窗口最大值**

#### **题目分析**

给定一个整数数组 `nums` 和一个整数 `k`，要求返回数组中每个大小为 `k` 的滑动窗口的最大值。问题的本质是：如何高效地在滑动窗口范围内找到最大值。

------

#### **解题思路**

利用**双端队列**(`Deque`)来维护窗口内的元素索引，实现一个时间复杂度为 **O(n)** 的算法：

1. 队列存储索引：
   - 双端队列用于存储数组元素的索引。
   - 队列中的索引对应的值保持单调递减顺序，这样队头始终是当前窗口的最大值索引。
2. 滑动窗口的操作：
   - **移除队头过期索引**：如果队头的索引小于窗口的左边界 `i - k + 1`，则从队头移除。
   - **移除小于当前元素的队尾值**：当前元素比队尾对应的值更大时，将队尾元素移除，保持单调性。
   - **加入当前元素索引**：将当前索引加入队列。
   - **记录结果**：当窗口大小达到 `k` 时，记录当前窗口的最大值（队头元素）。

------

#### **代码实现**

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        int[] result = new int[n - k + 1]; // 存储结果数组
        Deque<Integer> deque = new LinkedList<>(); // 双端队列，用于存储索引

        for (int i = 0; i < n; i++) {
            // 1. 移除队头过期索引（不在当前窗口范围内）
            if (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
                deque.pollFirst();
            }
            // 2. 移除队尾所有小于当前元素的值，保持单调递减
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }
            // 3. 将当前元素的索引加入队列
            deque.offerLast(i);
            // 4. 当窗口大小达到 k 时，记录窗口最大值
            if (i >= k - 1) {
                result[i - k + 1] = nums[deque.peekFirst()];
            }
        }
        return result;
    }
}
```

------

#### **代码解释**

1. **初始化**：
   - `result` 用于存储滑动窗口最大值。
   - `deque` 是双端队列，用于存储数组的索引。
2. **主循环**：
   - **移除过期索引**：确保队头的索引始终在窗口范围内。
   - **保持单调递减**：移除所有小于当前值的队尾元素，确保队头索引对应的值最大。
   - **记录结果**：窗口形成（`i >= k - 1`）时，将队头索引对应的值记录到结果中。

------

#### **复杂度分析**

- 时间复杂度：
  - 每个元素最多入队和出队一次，主循环中每次操作都是常数时间，所以整体时间复杂度为 **O(n)**。
- 空间复杂度：
  - 双端队列最多存储 `k` 个元素索引，因此空间复杂度为 **O(k)**。

------

#### **测试示例**

```java
public static void main(String[] args) {
    Solution solution = new Solution();
    int[] nums = {1, 3, -1, -3, 5, 3, 6, 7};
    int k = 3;
    System.out.println(Arrays.toString(solution.maxSlidingWindow(nums, k))); 
    // 输出: [3, 3, 5, 5, 6, 7]
}
```

------

#### **关键点总结**

1. **双端队列的设计**：
   - 通过队列维护窗口内最大值的索引，队头始终是当前窗口的最大值。
   - 删除过期索引（超出窗口范围）和小于当前值的索引，保证队列单调性。
2. **高效性**：
   - 每个元素只操作一次（入队或出队），时间复杂度 **O(n)**。
3. **灵活性**：
   - 双端队列方法不仅可以解决滑动窗口最大值问题，也可以应用于其他类似的窗口内统计问题。